<script>
  /* 時間軸：固定圓點 + 進入卡片即滿不透明、離開才衰減 */
  (() => {
    const rows = Array.from(document.querySelectorAll('.timeline-row'));
    if (!rows.length) return;

    const docStyle = getComputedStyle(document.documentElement);
    const minFade = parseFloat(docStyle.getPropertyValue('--row-min-fade')) || 0.35;

    let ticking = false;
    function updateRows(){
      const vh = window.innerHeight;
      const pinY = vh / 2;                         // 固定圓點的 Y（視窗正中央）
      const fadeRadius = Math.max(140, vh * 0.60); // 離開卡片後多遠開始→完全淡出

      rows.forEach(row=>{
        const rect = row.getBoundingClientRect();
        const top = rect.top;
        const bottom = rect.bottom;

        // 進入卡片上緣→滿不透明；只要圓點仍在卡片內，維持 1
        let opacity = 1;
        if (pinY < top || pinY > bottom) {
          // 在卡片外：對「距離最近的邊」做衰減
          const d = pinY < top ? (top - pinY) : (pinY - bottom);
          opacity = 1 - (d / fadeRadius);
          opacity = Math.max(minFade, Math.min(1, opacity));
        }

        const year = row.querySelector('.timeline-year');
        const card = row.querySelector('.timeline-card');
        if (year) year.style.opacity = opacity;
        if (card) card.style.opacity = Math.max(opacity, 0.5); // 卡片最低 0.5，看起來不要全沒
      });

      ticking = false;
    }

    function onScroll(){
      if(!ticking){
        requestAnimationFrame(updateRows);
        ticking = true;
      }
    }

    window.addEventListener('scroll', onScroll, {passive:true});
    window.addEventListener('resize', onScroll);
    onScroll();
  })();
</script>
